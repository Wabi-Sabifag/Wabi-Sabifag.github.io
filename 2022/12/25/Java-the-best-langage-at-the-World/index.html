<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java, the world's best programming language | 当你抬头仰望星辰时，月辉亲昵双颊</title><meta name="author" content="Wabi-Sabifag"><meta name="copyright" content="Wabi-Sabifag"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="栈的添加删除">
<meta property="og:type" content="article">
<meta property="og:title" content="Java, the world&#39;s best programming language">
<meta property="og:url" content="https://github.com/Wabi-Sabifag/Wabi-Sabifag.github.io/2022/12/25/Java-the-best-langage-at-the-World/index.html">
<meta property="og:site_name" content="当你抬头仰望星辰时，月辉亲昵双颊">
<meta property="og:description" content="栈的添加删除">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Wabi-Sabifag/Wabi-Sabifag.github.io/img/23.png">
<meta property="article:published_time" content="2022-12-25T14:10:52.000Z">
<meta property="article:modified_time" content="2023-11-05T03:21:47.104Z">
<meta property="article:author" content="Wabi-Sabifag">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="策略模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Wabi-Sabifag/Wabi-Sabifag.github.io/img/23.png"><link rel="shortcut icon" href="https://safebooru.org//samples/3404/sample_2d70be5f0453c31b5e9ad641db7cf3fb90ba2c23.jpg?3541071"><link rel="canonical" href="https://github.com/Wabi-Sabifag/Wabi-Sabifag.github.io/2022/12/25/Java-the-best-langage-at-the-World/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":730,"position":"top","messagePrev":"该版本已经是","messageNext":"天前的内容，请你仔细辨别版本和其他问题😉"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java, the world\'s best programming language',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-11-05 11:21:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,300&display=swap" rel="stylesheet"><meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="当你抬头仰望星辰时，月辉亲昵双颊" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://safebooru.org//samples/3404/sample_2d70be5f0453c31b5e9ad641db7cf3fb90ba2c23.jpg?3541071" onerror="onerror=null;src='https://safebooru.org//samples/3404/sample_2d70be5f0453c31b5e9ad641db7cf3fb90ba2c23.jpg?3541071'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 殿首</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-moon"></i><span> 吾の博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 故往尘飞、吾心犹然</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-earth"></i><span> 自然科学</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/nature/"><i class="fa-fw fas fa-sun"></i><span> 舒适の自然</span></a></li><li><a class="site-page child" href="/animal/"><i class="fa-fw fas fa-dog"></i><span> 可爱の动物</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-computer"></i><span> 社会科学</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/science/"><i class="fa-fw fas fa-ruler"></i><span> 理性科学</span></a></li><li><a class="site-page child" href="/history/"><i class="fa-fw fas fa-history"></i><span> 历史</span></a></li><li><a class="site-page child" href="/philosophy/"><i class="fa-fw fas fa-brain"></i><span> 哲学</span></a></li><li><a class="site-page child" href="/psychology/"><i class="fa-fw fas fa-heartbeat"></i><span> 心理</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 文学</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/hand/"><i class="fa-fw fas fa-hand"></i><span> 雕塑</span></a></li><li><a class="site-page child" href="/mask/"><i class="fa-fw fas fa-balance-scale"></i><span> 戏剧</span></a></li><li><a class="site-page child" href="/city/"><i class="fa-fw fas fa-city"></i><span> 建筑</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/sport/"><i class="fa-fw fas fa-basketball"></i><span> 体育</span></a></li><li><a class="site-page child" href="/hospital/"><i class="fa-fw fa fa-star"></i><span> 动漫</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fa fa-game"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-compass"></i><span> 其他信息</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-paper-plane"></i><span> --关于--</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/23.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">当你抬头仰望星辰时，月辉亲昵双颊</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 殿首</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-moon"></i><span> 吾の博客</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 故往尘飞、吾心犹然</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-earth"></i><span> 自然科学</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/nature/"><i class="fa-fw fas fa-sun"></i><span> 舒适の自然</span></a></li><li><a class="site-page child" href="/animal/"><i class="fa-fw fas fa-dog"></i><span> 可爱の动物</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-computer"></i><span> 社会科学</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/science/"><i class="fa-fw fas fa-ruler"></i><span> 理性科学</span></a></li><li><a class="site-page child" href="/history/"><i class="fa-fw fas fa-history"></i><span> 历史</span></a></li><li><a class="site-page child" href="/philosophy/"><i class="fa-fw fas fa-brain"></i><span> 哲学</span></a></li><li><a class="site-page child" href="/psychology/"><i class="fa-fw fas fa-heartbeat"></i><span> 心理</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/book/"><i class="fa-fw fas fa-book"></i><span> 文学</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/images/"><i class="fa-fw fas fa-images"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/hand/"><i class="fa-fw fas fa-hand"></i><span> 雕塑</span></a></li><li><a class="site-page child" href="/mask/"><i class="fa-fw fas fa-balance-scale"></i><span> 戏剧</span></a></li><li><a class="site-page child" href="/city/"><i class="fa-fw fas fa-city"></i><span> 建筑</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/sport/"><i class="fa-fw fas fa-basketball"></i><span> 体育</span></a></li><li><a class="site-page child" href="/hospital/"><i class="fa-fw fa fa-star"></i><span> 动漫</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fa fa-game"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-compass"></i><span> 其他信息</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-paper-plane"></i><span> --关于--</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java, the world's best programming language</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-25T14:10:52.000Z" title="发表于 2022-12-25 22:10:52">2022-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-05T03:21:47.104Z" title="更新于 2023-11-05 11:21:47">2023-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1.Java基础"></a>1.Java基础</h2><h3 id="1-关键词"><a href="#1-关键词" class="headerlink" title="1.关键词"></a>1.关键词</h3><h4 id="1-return"><a href="#1-return" class="headerlink" title="1.return"></a>1.return</h4><p>Java中 <strong>return</strong> 用法小结：</p>
<ul>
<li>return：必须放在方法中</li>
<li>return的主要作用有两点：<ul>
<li>1.<strong>返回</strong>方法<strong>指定类型值</strong></li>
<li>2.用于<strong>方法</strong>结束的标志,return 后面的语句不会被执行<ul>
<li>无返回类型</li>
<li>有返回类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">package test;
public class Test001 {
   public static void main(String[] args) {
       int i;
       System.out.println("return语句之前"+getInfo());
       for (i = 0; i &lt; 5; i++) {
           if(i==3){
               return;//无返回类型，用于方法的结束
           }
           System.out.println(String.format("i=%d",i));
       }
       //return 之后的语句将不会被执行
       System.out.println("return语句之后"+getInfo());
   }

   public static int getInfo(){
       return 1;//有返回类型，返回方法指定类型的返回值
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2.进制转换"></a>2.进制转换</h4><pre class="line-numbers language-none"><code class="language-none">10进制转化其他进制	对应的方法,参数:n(原10进制数据),r(进制),	返回值
10进制转2进制	Integer.toBinaryString(n);	一个二进制字符串.
10进制转8进制	Integer.toOctalString(n);	一个八进制字符串
10进制转16进制	Integer.toHexString(n);	一个16进制字符串
10进制转 r 进制	Integer.toString(100, 16);	一个r进制字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-实参与形参"><a href="#3-实参与形参" class="headerlink" title="3.实参与形参"></a>3.实参与形参</h4><mark class="hl-label default">形式参数</mark> ：是在**定义<mark class="hl-label default">函数名</mark> 和<mark class="hl-label default">函数体</mark> 的时候使用的参数**,目的是用来接收调用该函数时传入的参数。
<pre class="line-numbers language-none"><code class="language-none">public void sout(String name) { //形式参数为 name
    System.out.println(name);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>==实际参数==：在调用有参函数时，主调函数和被调函数之间有数据传递关系。<strong>在主调函数中调用一个函数时，函数名后面括号中的参数</strong>称为“<mark class="hl-label default">实际参数</mark> ”。</p>
<pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) {
    ParamTest pt = new ParamTest();
    pt.sout("Hollis");//实际参数为 Hollis
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际参数是<strong>调用<mark class="hl-label default">有参方法</mark> 的时候真正传递的内容</strong>，而形式参数是用于<strong>接收实参内容</strong>的参数</p>
<h4 id="4-值传递与引用传递"><a href="#4-值传递与引用传递" class="headerlink" title="4.值传递与引用传递"></a>4.值传递与引用传递</h4><mark class="hl-label default">值传递</mark> (pass by value)是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

<mark class="hl-label default">引用传递</mark> （pass by reference） 是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

<p>总结：</p>
<ol>
<li>Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。</li>
<li>无论是值传递还是引用传递，其实都是一种<mark class="hl-label default">求值策略</mark> (Evaluation strategy) 。在求值策略中，还有一种叫做<mark class="hl-label default">按共享传递</mark> (call by sharing)。其实Java中的参数传递严格意义上说应该是按共享传递，而按共享传递其实只是按值传递的一个特例罢了。</li>
</ol>
<p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。</p>
<ul>
<li>在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。</li>
<li>如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。</li>
<li>如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。</li>
</ul>
<h4 id="5-构造方法能重载，不能重写"><a href="#5-构造方法能重载，不能重写" class="headerlink" title="5.构造方法能重载，不能重写"></a>5.构造方法能重载，不能重写</h4><p>概述：<mark class="hl-label default">构造方法</mark> 存在于类中，给<strong>对象数据（属性）初始化</strong>；</p>
<p>特点：方法名与类名一样；无返回值无void;</p>
<p>默认构造方法：<br>我们不创建一个构造方法时，系统默认提供一个<mark class="hl-label default">无参构造</mark> ；<br>当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造</p>
<ol>
<li><mark class="hl-label default">重载</mark> ：存在于在一个类中，方法名相同，方法参数的<mark class="hl-label default">数据类型</mark> 或<mark class="hl-label default">方法的形式参数</mark> 个数不同</li>
<li><mark class="hl-label default">重写</mark> ：存在于子父类中，<mark class="hl-label default">方法名</mark> 、<mark class="hl-label default">方法参数</mark> 、<mark class="hl-label default">返回值</mark> 全部相同</li>
</ol>
<h4 id="6-抽象类、抽象方法"><a href="#6-抽象类、抽象方法" class="headerlink" title="6.抽象类、抽象方法"></a>6.抽象类、抽象方法</h4><h5 id="1-总结表述"><a href="#1-总结表述" class="headerlink" title="1. 总结表述"></a>1. 总结表述</h5><ul>
<li><mark class="hl-label default">抽象类</mark> 和<mark class="hl-label default">抽象方法</mark> 的产生是为了<mark class="hl-label default">维护继承链的逻辑</mark> ，即抽象类相对于那些普通的类处于**继承树的根部**。</li>
<li>抽象方法的产生完全是为了迎合抽象类的存在：抽象方法只能写在抽象类中！</li>
<li>抽象类的字段（反正也没有abstract抽象字段一说）只要像正常的继承关系那样使用就好了。</li>
<li>被abstract关键字修饰的类叫抽象类。</li>
<li>被abstract关键字修饰的方法叫抽象方法。</li>
</ul>
<h5 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. 核心思想</h5><ul>
<li>抽象类（abstract class）不能被<strong>实例化</strong>！！</li>
<li>抽象类是有<strong>构造器</strong>的（所有类都有构造器）</li>
<li>抽象类以有抽象方法，也可以没有抽象方法；但是抽象方法只能存在于抽象类中。</li>
<li>抽象类中的非抽象方法如同在非抽象类中一样，正常继承使用。</li>
<li>抽象方法（abstract method）只能存在于抽象类中！！</li>
<li>抽象方法所在的类，一定是抽象类<ul>
<li>因为抽象方法是没有<strong>方法体</strong>的，如果所在的类不是抽象类，那么该类可以<strong>实例化对象</strong>，调用抽象方法，然后无方法体去具体实现功能，则矛盾</li>
</ul>
</li>
<li>不存在所谓的抽象静态方法<ul>
<li>因为<mark class="hl-label default">静态方法</mark> 总是和一个<strong>类</strong>相绑定的，也因为这样我们使用类名而不是实例来调用某个类的静态方法；（反证法）如果一个抽象类的抽象方法被修饰为static的，我们推荐使用类名来调用该方法，即调用抽象类的静态方法（在「类」上面划着重号），可是又因为这个方法还被abstract修饰，是没有方法体的，我们不能直接调用（必须要现在子类中具体实现后才能调用）</li>
</ul>
</li>
</ul>
<h5 id="3-抽象类的使用："><a href="#3-抽象类的使用：" class="headerlink" title="3. 抽象类的使用："></a>3. 抽象类的使用：</h5><p>抽象类不能<strong>实例化</strong>（不能直接创建对象）。抽象类是用来被继承的，继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类，使用 abstract 关键字修饰。</p>
<p>抽象类也是类，因此原来类中可以有的成员，抽象类都可以有，那么抽象类不能直接创建对象，为什么还有构造器呢？供子类调用，子类创建对象时，需要为从父类继承的属性初始化。</p>
<p>抽象类不能使用final修饰。</p>
<h5 id="4-抽象类注意事项"><a href="#4-抽象类注意事项" class="headerlink" title="4. 抽象类注意事项"></a>4. 抽象类注意事项</h5><p>(1) 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<br>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。<br>(2) 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<br>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。<br>(3) 抽象类中，可以有成员变量。<br>理解：子类的共性的成员变量 , 可以定义在抽象父类中。<br>(4) 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。<br>理解：未包含抽象方法的抽象类，声明为抽象类目的就是不想让使用者创建该类的对象，通常用于某些特殊的类结构设计。<br>(5) 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译报错。除非该子类也是抽象类。<br>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
<h5 id="5-abstract关键字："><a href="#5-abstract关键字：" class="headerlink" title="5.abstract关键字："></a>5.abstract关键字：</h5><ol>
<li><p>可以用来修饰的结构：类、方法;不能用来修饰变量、代码块、构造器。</p>
</li>
<li><p>不能和 abstract 一起使用的修饰符：</p>
<ul>
<li>外部类可用修饰符：abstract、final </li>
<li>两种访问修饰符：public和缺省。</li>
<li>方法可用修饰符，不能共存的：4种访问修饰符<ul>
<li>不能被重写：static、final、abstract</li>
<li>没有方法体：native</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="7-构造函数-和-静态-static"><a href="#7-构造函数-和-静态-static" class="headerlink" title="7.构造函数 和 静态(static)"></a>7.构造函数 和 静态(static)</h4><h5 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h5><mark class="hl-label default">构造方法</mark> ：创建对象,给对象中的成员进行初始化
<p><strong>格式</strong>：</p>
<ul>
<li>1.方法名与类名相同</li>
<li>2.没有返回值类型，连void都没有</li>
<li>3.没有具体的返回值</li>
</ul>
<h5 id="2-静态"><a href="#2-静态" class="headerlink" title="2.静态"></a>2.静态</h5><p><strong>静态</strong>：<mark class="hl-label default">共享数据</mark> ，只存一份，并使其共享<br>static是一个修饰符，用于修饰成员（成员变量、成员函数）。<br>当成员被静态修饰后(多了一种调用方式)，除了可以被对象调用外，还可直接被类名调用（类名.静态成员）</p>
<h6 id="1-static-的特点"><a href="#1-static-的特点" class="headerlink" title="1.static 的特点"></a>1.static 的特点</h6><ol>
<li>随着类的加载而加载 当类加载到内存中，静态成员以及值也加载到内存中,也就是说，静态成员会随着类的消失而消失，他的生命周期最长</li>
<li>优先于对象存在</li>
<li>被所有对象所共享</li>
<li>可以被类名所调用<br>被<strong>静态修饰</strong>的成员变量被称为<mark class="hl-label default">态成员变量</mark> 静或者叫<mark class="hl-label default">类变量</mark> <br>没有被静态修饰的<strong>成员变量</strong>被称为<mark class="hl-label default">成员变量</mark> 或者叫<mark class="hl-label default">实例变量</mark> </li>
</ol>
<h6 id="2-实例变量和类变量的区别"><a href="#2-实例变量和类变量的区别" class="headerlink" title="2. 实例变量和类变量的区别"></a>2. 实例变量和类变量的区别</h6><ol>
<li>存放位置<br>类变量随着<strong>类的加载</strong>存在于<mark class="hl-label default">方法区</mark> 中<br>实例变量随着<strong>对象的建立</strong>存在于<mark class="hl-label default">堆内存</mark> 中</li>
<li>生命周期<br>类变量生命周期<strong>最长</strong>，随着类的消失而消失<br>实例变量生命周期随着对象的消失而消失</li>
</ol>
<h6 id="3-静态使用的注意事项"><a href="#3-静态使用的注意事项" class="headerlink" title="3.静态使用的注意事项"></a>3.静态使用的注意事项</h6><ol>
<li><mark class="hl-label default">静态方法</mark> 只能访问<mark class="hl-label default">静态成员</mark> ,非静态方法既可以访问静态也可以访非静态
<p><strong>原理</strong>：<mark class="hl-label default">生命周期</mark> 决定调用关系<br>非静态成员随着对象的创建而存在，静态方法优先于非静态存在，所以不可以调用未存在的方法和变量。而当非静态存在时，静态已经存在</p>
</li>
<li><p>静态方法中不可以定义this，super关键字<br>因为静态<strong>优先于</strong>对象存在，所以静态方法中不可以出现this关键字<br><strong>优点</strong>：<br> 1.对<strong>对象的共享数据</strong>进行单独空间的存储，节省堆内存空间<br> 2.可以直接<strong>被类名调用</strong><br><strong>缺点</strong>：<br> 1.生命周期过长，占用<strong>内存</strong><br> 2.<strong>访问</strong>出现<strong>局限性</strong>，静态只能访问静态</p>
</li>
</ol>
<h4 id="8-Cookie和Session的区别"><a href="#8-Cookie和Session的区别" class="headerlink" title="8.Cookie和Session的区别"></a>8.Cookie和Session的区别</h4><h5 id="1-共同之处："><a href="#1-共同之处：" class="headerlink" title="1.共同之处："></a>1.共同之处：</h5><p>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<h5 id="2-工作原理："><a href="#2-工作原理：" class="headerlink" title="2.工作原理："></a>2.工作原理：</h5><h6 id="1-Cookie的工作原理"><a href="#1-Cookie的工作原理" class="headerlink" title="1.Cookie的工作原理"></a>1.Cookie的工作原理</h6><p>（1）浏览器端第一次发送请求到服务器端<br>（2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端<br>（3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie<br>（4）<strong>服务器端</strong>通过Cookie中携带的数据<strong>区分</strong>不同的用户</p>
<h6 id="2-Session的工作原理"><a href="#2-Session的工作原理" class="headerlink" title="2.Session的工作原理"></a>2.Session的工作原理</h6><p>（1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个<strong>特殊的Cookie</strong>（<strong>name</strong>为<mark class="hl-label default">JSESSIONID的固定值</mark> ，<strong>value</strong>为<mark class="hl-label default">session对象的ID</mark> ），然后将该Cookie发送至浏览器端<br>（2）浏览器端发送第N（N&gt;1）次请求到服务器端,<strong>浏览器端</strong>访问<strong>服务器端</strong>时就会携带该<strong>name</strong>为<mark class="hl-label default">JSESSIONID</mark> 的<strong>Cookie对象</strong><br>（3）服务器端根据name为JSESSIONID的Cookie的value(<strong>sessionId</strong>),去查询Session对象，从而区分不同用户。</p>
<ul>
<li>name为JSESSIONID的Cookie<strong>不存在</strong>（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookie</li>
<li>name为JSESSIONID的Cookie<strong>存在</strong>，根据<strong>value</strong>中的<strong>SessionId</strong>去寻找<strong>session对象</strong><ul>
<li>value为SessionId不存在（Session对象默认存活30分钟），返回1中重新去创建Session与特殊的Cookie</li>
<li>value为SessionId存在，返回session对象</li>
</ul>
</li>
</ul>
<h5 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h5><p>cookie数据保存在<strong>客户端</strong>，session数据保存在<strong>服务端</strong>。<br>session过期与否，取决于服务器的设定。cookie过期与否，可以在cookie生成的时候设置进去</p>
<h6 id="1-session："><a href="#1-session：" class="headerlink" title="1.session："></a>1.session：</h6><p>简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</p>
<h6 id="2-cookie："><a href="#2-cookie：" class="headerlink" title="2.cookie："></a>2.cookie：</h6><p>sessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。</p>
<h5 id="4-区别对比："><a href="#4-区别对比：" class="headerlink" title="4.区别对比："></a>4.区别对比：</h5><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到<strong>安全应当使用session</strong><br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器<strong>性能方面应当使用COOKIE</strong><br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p>
<h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h3><h4 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h4><h5 id="1-List数据的指定修改"><a href="#1-List数据的指定修改" class="headerlink" title="1.List数据的指定修改"></a>1.List数据的指定修改</h5><pre class="line-numbers language-none"><code class="language-none">package ArrayForiter;
import java.util.*;
import java.util.stream.*;

import org.junit.jupiter.api.Test;
public class ListItemRemoveTests {
 public List&lt;String&gt; initList = Arrays.asList("360","aliyun","baidu","bilibili","amazon","bytedance","Tencent");
 /*
  * 增强for循环删除 ConcurrentModificationException
  */
 public void test1() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  for(String element : list) {
   if(element.startsWith("b")) {
    list.remove(element);
   }
  }
  System.out.println(list);
 }
 @Test
 public void test1_1() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  list.forEach ((e) -&gt; {
   if(e.startsWith("b")) {
    list.remove(e);
   }
  });
  System.out.println(list);
  
 }
 
 /* 低级for size, 删除不全。（功能不完善的 bug */
 public void test2() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  for (int i = 0; i &lt; list.size(); i++) {
   String str = list.get(i);
   if(str.startsWith("b")) {
    list.remove(i);
   }
  }
  System.out.println(list);
 }
 
 /* 
  * 角标越界
  * 无法阻止 for的i增大 
 */
 public void test3() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  int size = list.size();
  for (int i = 0; i &lt; size; i++) {
   String str = list.get(i);
   if(str.startsWith("b")) {
    list.remove(i);
   }
  }
  System.out.println(list);
 }

 /*
  * 逆序删除 
  * 从后面开始，可以改变 for 增大导致的角标越界
  */
 public void test4() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  for(int i=list.size()-1;i&gt;0;i--) {
   String str = list.get(i);
   if(str.startsWith("b")) {
    list.remove(i);
   }
  }
  System.out.println(list);
 }

 /*
  * 调用 iteration 提供的方法
  */
 public void test5() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  for(Iterator&lt;String&gt; iterator = list.iterator();iterator.hasNext();) {
   String str = iterator.next();
   if(str.startsWith("b")) {
    iterator.remove();
   }
  }
  System.out.println(list);
 }
 
 public void test5_1() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  for(Iterator&lt;String&gt; iterator = list.iterator();iterator.hasNext();) {
   String str = iterator.next();
   if(str.startsWith("b")) {
    list.remove(str);  // 用的 iterat 方法 但没在关键点用iterator.remove();
   }
  }
  System.out.println(list);
 }

 /*
  * filter 过滤 
  * 得到一定量的反向元素
  */
 public void test6() {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;(initList);
  list = list.stream().filter(e -&gt; !e.startsWith("b")).collect(Collectors.toList());
  System.out.println(list);
 }
 
 
 public static void main(String[] s) {
  ListItemRemoveTests a = new ListItemRemoveTests();
  
  /*
   * 原因： Iterator迭代时不能remove。 
   * 	是同步操作问题  两者修改次数不一致
   */
  //a.test1();
  //a.test1_1();
  
  //a.test2();
  //a.test3();
  
  a.test4();
  a.test5();
  
  /*
   * 用的 iterat 方法 但没在关键点用iterator.remove();
   */
  //a.test5_1();
  
  a.test6();
 }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="2-MySQL基础"><a href="#2-MySQL基础" class="headerlink" title="2.MySQL基础"></a>2.MySQL基础</h2><h3 id="1-数据库类型"><a href="#1-数据库类型" class="headerlink" title="1.数据库类型"></a>1.数据库类型</h3><h4 id="1-五大类型"><a href="#1-五大类型" class="headerlink" title="1.五大类型"></a>1.五大类型</h4><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/487301863">各类型的具体值和定义</a></p>
<h5 id="1-整数类型："><a href="#1-整数类型：" class="headerlink" title="1.整数类型："></a>1.整数类型：</h5><p>BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</p>
<h5 id="2-浮点数类型："><a href="#2-浮点数类型：" class="headerlink" title="2.浮点数类型："></a>2.浮点数类型：</h5><p>FLOAT、DOUBLE、DECIMAL</p>
<h5 id="3-字符串类型："><a href="#3-字符串类型：" class="headerlink" title="3.字符串类型："></a>3.字符串类型：</h5><p>CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</p>
<h5 id="4-日期类型："><a href="#4-日期类型：" class="headerlink" title="4.日期类型："></a>4.日期类型：</h5><p>Date、DateTime、TimeStamp、Time、Year</p>
<h5 id="5-其他数据类型："><a href="#5-其他数据类型：" class="headerlink" title="5.其他数据类型："></a>5.其他数据类型：</h5><p>BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</p>
<h5 id="6-相似数据间的区别"><a href="#6-相似数据间的区别" class="headerlink" title="6.相似数据间的区别"></a>6.相似数据间的区别</h5><h6 id="1-int-1-与int-10-的区别？"><a href="#1-int-1-与int-10-的区别？" class="headerlink" title="1.int(1)与int(10)的区别？"></a>1.int(1)与int(10)的区别？</h6><p>规定类型之后，储存是定长的。从本身长度还是储存方式都是一样的，最大值都是-2^31到2^31-1，没有区别。<br>唯一区别就是设置zerofill，如：int(<strong>4</strong>) 设置之后会<strong>自动左边补零显示</strong>：0001。</p>
<h6 id="2-tinyint-1-与tinyint-3-的区别？"><a href="#2-tinyint-1-与tinyint-3-的区别？" class="headerlink" title="2.tinyint(1)与tinyint(3)的区别？"></a>2.tinyint(1)与tinyint(3)的区别？</h6><p>基本与int区别一样，唯一区别就是设置zerofill，如：tinyint(<strong>6</strong>) 设置之后会<strong>自动左边补零显示</strong>：000001，但最大值还是255。</p>
<h6 id="3-char与varchar的区别？"><a href="#3-char与varchar的区别？" class="headerlink" title="3.char与varchar的区别？"></a>3.char与varchar的区别？</h6><p>char是<strong>固定长度</strong>，不管实际存储数据的长度，按char<strong>规定长度分配空间</strong>，会截断尾部的空格。<br>varchar是<strong>可变长度</strong>，会根据<strong>实际存储数据的长度</strong>分配最终的存储空间，<strong>实际占用的字节+1</strong>。<br>char(n)、varchar(n)中的n都是代表字符的个数，超过最大长度n的限制之后，字符串会被<strong>截断</strong>。</p>
<h6 id="4-BLOB与TEXT的区别？"><a href="#4-BLOB与TEXT的区别？" class="headerlink" title="4.BLOB与TEXT的区别？"></a>4.BLOB与TEXT的区别？</h6><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB。<br>TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。<br>BLOB 保存<strong>二进制数据</strong>，TEXT 保存<strong>字符数据</strong>。</p>
<h2 id="3-Redis基础"><a href="#3-Redis基础" class="headerlink" title="3. Redis基础"></a>3. Redis基础</h2><h3 id="1-token-过期后，如何自动续期？"><a href="#1-token-过期后，如何自动续期？" class="headerlink" title="1.token 过期后，如何自动续期？"></a>1.token 过期后，如何自动续期？</h3><p>JWT token的 payload 部分是一个json串，是要传递数据的一组声明，这些声明被JWT标准称为claims。</p>
<p>JWT标准里面定义的标准claim包括：</p>
<ul>
<li>iss(Issuser)：JWT的签发主体；</li>
<li>sub(Subject)：JWT的所有者；</li>
<li>aud(Audience)：JWT的接收对象；</li>
<li>exp(Expiration time)：JWT的过期时间；</li>
<li>nbf(Not Before)：JWT的生效开始时间；</li>
<li>iat(Issued at)：JWT的签发时间；</li>
<li>jti(JWT ID)：是JWT的唯一标识。<br>  除了以上标准声明以外，我们还可以自定义声明。以 com.auth0 为例，下面代码片段实现了生成一个带有过期时间的token.<pre class="line-numbers language-none"><code class="language-none">String token = JWT.create()
    .withIssuer(ISSUER)
    .withIssuedAt(new Date(currentTime))// 签发时间
    .withExpiresAt(new Date(currentTime + EXPIRES_IN * 1000 * 60))// 过期时间戳
    .withClaim("username", username)//自定义参数
    .sign(Algorithm.HMAC256(user.getPassword()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
其中：</li>
<li>withIssuer() 设置签发主体；</li>
<li>withIssuedAt() 设置签发时间；</li>
<li>withExpiresAt() 设置过期时间戳，过期的时长为 EXPIRES_IN （单位秒）；</li>
<li>withClaim() 设置自定义参数。<br>  JWT设置了过期时间以后，一定超过，那么接口就不能访问了，需要用户重新登录获取token。如果经常需要用户重新登录，显然这种体验不是太好，因此很多应用会采用<strong>token过期后自动续期</strong>的方案，只有特定条件下才会让用户重新登录。</li>
</ul>
<h4 id="1-token过期的续期方案"><a href="#1-token过期的续期方案" class="headerlink" title="1.token过期的续期方案"></a>1.token过期的续期方案</h4><p>解决token过期的续期问题可以有很多种不同的方案，这里举一些比较有代表性的例子。首先我们看一个单token方案，这个方案除了可以实现token续期以外，还可以实现某些条件下的强制重新登录。</p>
<h5 id="1-单token方案"><a href="#1-单token方案" class="headerlink" title="1.单token方案"></a>1.单token方案</h5><p><a href="../JavaEE/javaBase-1.png">单token方案</a></p>
<ul>
<li><p>将 token 过期时间设置为15分钟；</p>
</li>
<li><p>前端发起请求，后端验证 token 是否过期；</p>
<ul>
<li>如果过期，前端发起刷新token请求，后端为前端返回一个新的token；</li>
<li>前端用新的token发起请求，请求成功；</li>
</ul>
</li>
<li><p>如果要实现每隔72小时，必须重新登录，后端需要记录每次用户的登录时间；</p>
<ul>
<li>用户每次请求时，检查用户最后一次登录日期</li>
<li>如超过72小时，则拒绝刷新token的请求，请求失败，跳转到登录页面。</li>
</ul>
<p>  另外后端还可以<strong>记录刷新token的次数</strong>，比如最多刷新50次，如果达到50次，则不再允许刷新，需要用户重新授权。</p>
</li>
</ul>
<h5 id="2-双token方案"><a href="#2-双token方案" class="headerlink" title="2.双token方案"></a>2.双token方案</h5><ul>
<li>登录成功以后，后端返回<mark class="hl-label default">access_token</mark>   和 <mark class="hl-label default">refresh_token</mark> ，客户端缓存此<strong>两种</strong>token;</li>
</ul>
<ul>
<li>客服端<ul>
<li>使用 <mark class="hl-label default">access_token</mark>  请求接口资源，成功则调用成功；</li>
<li>如果<strong>token超时</strong>，客户端携带 <mark class="hl-label default">refresh_token</mark>  调用token刷新接口获取新的 <mark class="hl-label default">access_token</mark> ;</li>
</ul>
</li>
<li>服务端<ul>
<li>后端接受刷新token的请求后，检查 <mark class="hl-label default">refresh_token</mark>  是否过期。<ul>
<li>如果<strong>过期</strong>，<strong>拒绝刷新</strong>，客户端收到该状态后，跳转到登录页；</li>
<li>如果<strong>未过期</strong>，生成新的 <mark class="hl-label default">access_token</mark> 返回给客户端。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>客户端携带新的 <mark class="hl-label default">access_token</mark>  重新调用上面的资源接口。</li>
<li>客户端退出登录或修改密码后，注销旧的token，使 <mark class="hl-label default">access_token</mark>  和 <mark class="hl-label default">refresh_token</mark>  失效，同时清空客户端的 <mark class="hl-label default">access_token</mark>  和 <mark class="hl-label default">refresh_token</mark> 。</li>
</ul>
<p>微信网页授权是通过OAuth2.0机制实现的，也使用了双token方案。</p>
<h5 id="3-微信网页授权方案"><a href="#3-微信网页授权方案" class="headerlink" title="3.微信网页授权方案"></a>3.微信网页授权方案</h5><ul>
<li>客服端<ul>
<li>用户在第三方应用的网页上完成微信授权以后，第三方应用可以获得 <strong>code</strong>（授权码）。code的超时时间为10分钟，一个code只能成功换取一次<mark class="hl-label default">access_token</mark> 即失效。</li>
</ul>
</li>
<li>服务端<ul>
<li>第三方应用通过code获取网页授权凭证<mark class="hl-label default">access_token</mark> 和刷新凭证 <mark class="hl-label default">refresh_token</mark> 。</li>
</ul>
</li>
</ul>
<mark class="hl-label default">access_token</mark> n是调用授权关系接口的调用凭证，由于<mark class="hl-label default">access_token</mark> 有效期（2个小时）较短，当<mark class="hl-label default">access_token</mark> 超时后，可以使用<mark class="hl-label default">refresh_token</mark> 进行刷新。
<mark class="hl-label default">refresh_token</mark> 拥有较长的有效期（30天），当r<mark class="hl-label default">refresh_token</mark> 失效的后，需要用户重新授权。

<h5 id="4-Redis缓存token"><a href="#4-Redis缓存token" class="headerlink" title="4.Redis缓存token"></a>4.Redis缓存token</h5><p>后端实现token过期还可以利用Redis来存储token，设置redis的键值对的过期时间。如果发现redis中不存在token的记录，说明token已经过期了。</p>
<p>通过使用Redis的字符串数据结构，我们可以轻松地存储和管理Token。同时，我们展示了如何在每次验证时延长Token的过期时间，以实现Token的自动过期和续期。使用Redis作为Token存储和管理的解决方案，可以提高系统的性能和可扩展性。</p>
<h6 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h6><h4 id="2-token失效处理方案"><a href="#2-token失效处理方案" class="headerlink" title="2.token失效处理方案"></a>2.token失效处理方案</h4><h5 id="1-主动处理"><a href="#1-主动处理" class="headerlink" title="1.主动处理"></a>1.主动处理</h5><h6 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h6><ul>
<li>token产生（存入本地）时的<mark class="hl-label default">时间戳</mark> ：用户成功登录，存token时记下此刻的<strong>时间戳A</strong></li>
<li>token使用的时间戳：axios的请求拦截器中，请求会自动携带token，这就是使用token的时候，记下此刻的<strong>时间戳B</strong></li>
<li>检查是否过期：时间差 = 时间戳B - 时间戳A ，将<strong>时间差</strong>与指定的token<strong>有效时长</strong>对比。如果大于有效时长，表示已经过期；如果小于有效时长，表示没过期<ul>
<li>不同情况的处理<ul>
<li>已经过期：<ul>
<li>退出登录–清空token、当前用户信息，跳转到登录页</li>
<li>更换token</li>
</ul>
</li>
<li>没过期：<ul>
<li>业务照常进行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h6><div class="tabs" id="装包js-cookie"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#装包js-cookie-1">装包js-cookie</button></li><li class="tab"><button type="button" data-href="#装包js-cookie-2">login.vue</button></li><li class="tab"><button type="button" data-href="#装包js-cookie-3">request.js</button></li><li class="tab"><button type="button" data-href="#装包js-cookie-4">request.js</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="装包js-cookie-1"><pre class="line-numbers language-none"><code class="language-none">/* src/utils/auth.js */
import Cookies from 'js-cookie'

// 定义时间戳的key
const timeKey = 'hr-timestamp'

// 存时间戳
export function setTimeStamp() {
  return Cookies.set(timeKey, Date.now())
}

// 读时间戳
export function getTimeStamp() {
  return Cookies.get(timeKey)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="装包js-cookie-2"><pre class="line-numbers language-none"><code class="language-none">到Vuex中的登录函数中，记下登录成功时的时间戳
import { setTimeStamp } from '@/utils/auth.js'
const actions = {
  /* 一、定义函数：用户登录 */
  /* 调用处：点击登录按钮时 */
  async login(context, payload) {
  
    // 1.发请求
    const res = await loginApi(payload)

    // 2. 存登录成功后的token ,token在响应数据res.data中
    context.commit('SET_TOKEN', res.data)
    
    // 3. token过期的主动处理：记下存token时的时间戳
    setTimeStamp()
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="装包js-cookie-3"><pre class="line-numbers language-none"><code class="language-none">定义过期时长、判断过期函数
/* src/utils/request.js */
import store from '@/store' 
import { getTimeStamp } from '@/utils/auth'
import router from '@/router'

// 定义过期时长
const TimeOut = 3600 // 单位：秒
// 定义判断过期函数
function checkTimeOut() {
  // 当前时间
  const currentTime = Date.now() 
  // 读取存token时的时间戳
  const timeStamp = getTimeStamp() 
  // 转换为秒后再比较
  const flag = ((currentTime - timeStamp) / 1000) &gt; TimeOut 
  // 返回布尔值
  return flag 
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="装包js-cookie-4"><pre class="line-numbers language-none"><code class="language-none">请求拦截器中，编写业务逻辑
service.interceptors.request.use(
  (config) =&gt; {
    const token = store.getters.token  // 尝试读取token
    if (token) {
      /* token过期的主动处理 */
      if (checkTimeOut()) {
        /* return的flag为false，表示过期 */
        // 触发actions中的logout函数，清空当前过期的token（防止页面跳转错误）、清空用户信息
        store.dispatch('user/logout')
        // 跳转到登录页
        router.push({ path: '/login' })
        // return抛出一个执行错误, 用于终止promise的执行链
        return Promise.reject(new Error('token超时，请重新登录'))
      }
      // 如果token存在,就自动添加到请求头上
      // 注意：使用动态添加属性的形式。
      // 原因：如果headers中的Authorization之前不存在，这样能添加一个新属性；如果headers中的Authorization之前存在，这样能覆盖以前的token值
      config.headers['Authorization'] = `Bearer ${token}`
    }
    return config
  },
  
  (error) =&gt; {
    return Promise.reject(error)
  }
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h5 id="2-被动处理"><a href="#2-被动处理" class="headerlink" title="2.被动处理"></a>2.被动处理</h5><h6 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h6><ul>
<li>每次请求成功发送后，都会得到服务器的响应。经过后端的判断，如果当前的token失效，那么一定会在响应的数据中携带一个<strong>标识</strong>。或者说返回一个错误状态码，例如code：233333</li>
<li>token过期属于响应失败，axios响应拦截器中的第二个回调会被触发</li>
<li>在响应拦截器的第二个回调中，编写token失效的业务逻辑：<ul>
<li>清除当前的失效token（防止页面无法跳转）；</li>
<li>跳转到登录页；return一个执行错误，用于终止当前的promise执行链</li>
</ul>
</li>
</ul>
<h6 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h6><pre class="line-numbers language-none"><code class="language-none">service.interceptors.response.use(
  (response) =&gt; {
      // dosomething
  },
  (error) =&gt; {
    // ! 服务器响应失败时，干些事情： 导致响应失败的原因有很多，其中之一是 token 过期
    // 响应失败时的error(错误对象)，它经过了axios的2层包装，服务器响应的真实数据在 error.response.data 中。
    // axios包装的提示信息是：error.message，与服务器响应的真实数据是两回事
    const realData = error.response.data
    /* 处理token失效---后端处理 */
    if (error.response &amp;&amp; realData &amp;&amp; realData.code === 233333) {
      // 以上三个条件全部满足时，才说明token超时
      // 1. 触发actions中的logout函数，清除无效token、当前用户信息
      store.dispatch('user/logout')
      // 2. 跳转到登录页面
      router.push({ path: '/login' })
      // 3. return 一个执行错误，用于终止当前的promise执行链
      return Promise.reject(error)
    } else {
      /*  如果token未失效，则是其他错误 */
      // 1. 提示错误信息
      Message.error(realData.message)
      // 2. return 一个执行错误
      return Promise.reject(error)
    }
  }
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>








<h2 id="4-Java策略模式"><a href="#4-Java策略模式" class="headerlink" title="4.Java策略模式"></a>4.Java策略模式</h2><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：<strong>创建型模式</strong>（Creational Patterns）、<strong>结构型模式</strong>（Structural Patterns）、<strong>行为型模式</strong>（Behavioral Patterns）<br><a href="../JavaEE/javaBase-2.jpg">Java模式设计关系图</a></p>
<p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<ul>
<li>设计模式优点<ul>
<li>提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。</li>
<li>提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。</li>
<li>促进了代码的重用，避免了重复的设计和实现。</li>
<li>通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量</li>
</ul>
</li>
</ul>
<h4 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h4><h5 id="1-开闭原则（Open-Close-Principle）"><a href="#1-开闭原则（Open-Close-Principle）" class="headerlink" title="1.开闭原则（Open Close Principle）"></a>1.开闭原则（Open Close Principle）</h5><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h5 id="2-里氏代换原则（Liskov-Substitution-Principle）"><a href="#2-里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2.里氏代换原则（Liskov Substitution Principle）"></a>2.里氏代换原则（Liskov Substitution Principle）</h5><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何<strong>基类</strong>可以出现的地方，<strong>子类</strong>一定可以出现。LSP 是继承复用的基石，只有当<strong>派生类</strong>可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h5 id="3-依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3-依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3.依赖倒转原则（Dependence Inversion Principle）"></a>3.依赖倒转原则（Dependence Inversion Principle）</h5><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<h5 id="4-接口隔离原则（Interface-Segregation-Principle）"><a href="#4-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4.接口隔离原则（Interface Segregation Principle）"></a>4.接口隔离原则（Interface Segregation Principle）</h5><p>这个原则的意思是：<strong>使用多个隔离的接口，比使用单个接口要好</strong>。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<h5 id="5-迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5-迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5.迪米特法则，又称最少知道原则（Demeter Principle）"></a>5.迪米特法则，又称最少知道原则（Demeter Principle）</h5><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块<strong>相对独立</strong>。</p>
<h5 id="6-合成复用原则（Composite-Reuse-Principle）"><a href="#6-合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6.合成复用原则（Composite Reuse Principle）"></a>6.合成复用原则（Composite Reuse Principle）</h5><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h3 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1.创建型模式"></a>1.创建型模式</h3><h4 id="1-工厂模式（Factory-Pattern）"><a href="#1-工厂模式（Factory-Pattern）" class="headerlink" title="1.工厂模式（Factory Pattern）"></a>1.工厂模式（Factory Pattern）</h4><p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将<strong>对象的创建</strong>与<strong>使用</strong>代码分离，提供一种统一的接口来创建不同类型的对象。</p>
<h5 id="1-意图"><a href="#1-意图" class="headerlink" title="1.意图"></a>1.意图</h5><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>主要解决：主要解决接口选择的问题。</p>
<h5 id="2-工厂模式包含以下几个核心角色："><a href="#2-工厂模式包含以下几个核心角色：" class="headerlink" title="2.工厂模式包含以下几个核心角色："></a>2.工厂模式包含以下几个核心角色：</h5><ul>
<li>抽象产品（Abstract Product）：<strong>定义</strong>了产品的<strong>共同接口</strong>或<strong>抽象类</strong>。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。</li>
<li>具体产品（Concrete Product）：<strong>实现</strong>了抽象产品接口，定义了具体产品的特定行为和属性。</li>
<li>抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。</li>
<li>具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。</li>
</ul>
<h5 id="3-工厂模式实现"><a href="#3-工厂模式实现" class="headerlink" title="3.工厂模式实现"></a>3.工厂模式实现</h5><p><a href="../JavaEE/javaBase-3.jpg">工厂模式</a><br>创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。</p>
<p>FactoryPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。</p>
<h6 id="1-创建接口"><a href="#1-创建接口" class="headerlink" title="1.创建接口"></a>1.创建接口</h6><p>Shape.java</p>
<pre class="line-numbers language-none"><code class="language-none">public interface Shape {
   void draw();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h6 id="2-创建实现接口的实体类"><a href="#2-创建实现接口的实体类" class="headerlink" title="2.创建实现接口的实体类"></a>2.创建实现接口的实体类</h6><div class="tabs" id="rectangle.java"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#rectangle.java-1">Rectangle.java</button></li><li class="tab"><button type="button" data-href="#rectangle.java-2">Square.java</button></li><li class="tab"><button type="button" data-href="#rectangle.java-3">Circle.java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="rectangle.java-1"><pre class="line-numbers language-none"><code class="language-none">public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="rectangle.java-2"><pre class="line-numbers language-none"><code class="language-none">public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="rectangle.java-3"><pre class="line-numbers language-none"><code class="language-none">public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h6 id="3-创建一个工厂，生成基于给定信息的实体类的对象"><a href="#3-创建一个工厂，生成基于给定信息的实体类的对象" class="headerlink" title="3.创建一个工厂，生成基于给定信息的实体类的对象"></a>3.创建一个工厂，生成基于给定信息的实体类的对象</h6><pre class="line-numbers language-none"><code class="language-none">public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="4-使用该工厂，通过传递类型信息来获取实体类的对象"><a href="#4-使用该工厂，通过传递类型信息来获取实体类的对象" class="headerlink" title="4.使用该工厂，通过传递类型信息来获取实体类的对象"></a>4.使用该工厂，通过传递类型信息来获取实体类的对象</h6><pre class="line-numbers language-none"><code class="language-none">public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2.抽象工厂模式（Abstract Factory Pattern）"></a>2.抽象工厂模式（Abstract Factory Pattern）</h4><h5 id="1-意图-1"><a href="#1-意图-1" class="headerlink" title="1.意图"></a>1.意图</h5><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p>
<p>主要解决：主要解决接口选择的问题</p>
<h5 id="2-抽象工厂模式实现"><a href="#2-抽象工厂模式实现" class="headerlink" title="2.抽象工厂模式实现"></a>2.抽象工厂模式实现</h5><p><a href="../JavaEE/javaBase-4.jpg">抽象工厂模式实现</a><br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。</p>
<p>AbstractFactoryPatternDemo 类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。</p>
<div class="tabs" id="shape.java"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#shape.java-1">Shape.java</button></li><li class="tab"><button type="button" data-href="#shape.java-2">Rectangle.java</button></li><li class="tab"><button type="button" data-href="#shape.java-3">Color.java</button></li><li class="tab"><button type="button" data-href="#shape.java-4">Red.java</button></li><li class="tab"><button type="button" data-href="#shape.java-5">AbstractFactory.java</button></li><li class="tab"><button type="button" data-href="#shape.java-6">ShapeFactory.java</button></li><li class="tab"><button type="button" data-href="#shape.java-7">ColorFactory.java</button></li><li class="tab"><button type="button" data-href="#shape.java-8">FactoryProducer.java</button></li><li class="tab"><button type="button" data-href="#shape.java-9">FactoryProducer.java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="shape.java-1"><pre class="line-numbers language-none"><code class="language-none">public interface Shape {
   void draw();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-2"><pre class="line-numbers language-none"><code class="language-none">//创建实现接口的实体类。
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-3"><pre class="line-numbers language-none"><code class="language-none">public interface Color {
   void fill();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-4"><pre class="line-numbers language-none"><code class="language-none">// 创建实现接口的实体类
public class Red implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Red::fill() method.");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-5"><pre class="line-numbers language-none"><code class="language-none">// 为 Color 和 Shape 对象创建抽象类来获取工厂。
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-6"><pre class="line-numbers language-none"><code class="language-none">// 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-7"><pre class="line-numbers language-none"><code class="language-none">// 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase("RED")){
         return new Red();
      } else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
      } else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      return null;
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-8"><pre class="line-numbers language-none"><code class="language-none">// 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){

      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
      }  
   if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }

      return null;
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-9"><pre class="line-numbers language-none"><code class="language-none">// 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。
public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {
 
      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
 
      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();


      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
 
      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor("RED");
 
      //调用 Red 的 fill 方法
      color1.fill();
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>


<h4 id="3-单例模式（Singleton-Pattern）"><a href="#3-单例模式（Singleton-Pattern）" class="headerlink" title="3.单例模式（Singleton Pattern）"></a>3.单例模式（Singleton Pattern）</h4><p><a href="../JavaEE/javaBase-5.jpg">单例模式</a></p>
<h5 id="1-意图："><a href="#1-意图：" class="headerlink" title="1.意图："></a>1.意图：</h5><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<h5 id="2-单例模式实现"><a href="#2-单例模式实现" class="headerlink" title="2.单例模式实现"></a>2.单例模式实现</h5><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。</p>
<p>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo 类使用 SingleObject 类来获取 SingleObject 对象。</p>
<div class="tabs" id="singleobject.java"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#singleobject.java-1">SingleObject.java</button></li><li class="tab"><button type="button" data-href="#singleobject.java-2">SingletonPatternDemo.java</button></li><li class="tab"><button type="button" data-href="#singleobject.java-3">非线程安全</button></li><li class="tab"><button type="button" data-href="#singleobject.java-4">线程安全</button></li><li class="tab"><button type="button" data-href="#singleobject.java-5">饿汉模式</button></li><li class="tab"><button type="button" data-href="#singleobject.java-6">双重校验锁</button></li><li class="tab"><button type="button" data-href="#singleobject.java-7">静态内部内</button></li><li class="tab"><button type="button" data-href="#singleobject.java-8">枚举</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="singleobject.java-1"><pre class="line-numbers language-none"><code class="language-none">public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-2"><pre class="line-numbers language-none"><code class="language-none">//从 singleton 类获取唯一的对象。
public class SingletonPatternDemo {
   public static void main(String[] args) {
 
      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();
 
      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();
 
      //显示消息
      object.showMessage();
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-3"><pre class="line-numbers language-none"><code class="language-none">public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-4"><pre class="line-numbers language-none"><code class="language-none">public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  

    public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-5"><pre class="line-numbers language-none"><code class="language-none">public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  

    public static Singleton getInstance() {  
    	return instance;  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-6"><pre class="line-numbers language-none"><code class="language-none">//这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  

    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-7"><pre class="line-numbers language-none"><code class="language-none">public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  

    private Singleton (){}  

    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="singleobject.java-8"><pre class="line-numbers language-none"><code class="language-none">public enum Singleton {  
    INSTANCE;  
    public void whateverMethod(){}  
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>


<h4 id="4-建造者模式（Builder-Pattern）"><a href="#4-建造者模式（Builder-Pattern）" class="headerlink" title="4.建造者模式（Builder Pattern）"></a>4.建造者模式（Builder Pattern）</h4><p><a href="../JavaEE/javaBase-6.jpg">建造者模式</a></p>
<h5 id="1-意图：-1"><a href="#1-意图：-1" class="headerlink" title="1.意图："></a>1.意图：</h5><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p>主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<h5 id="2-建造者模式实现"><a href="#2-建造者模式实现" class="headerlink" title="2.建造者模式实现"></a>2.建造者模式实现</h5><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。</p>
<div class="tabs" id="item.java"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#item.java-1">Item/Packing.java</button></li><li class="tab"><button type="button" data-href="#item.java-2">WrapperBottle.java</button></li><li class="tab"><button type="button" data-href="#item.java-3">Burger/ColdDrink.java</button></li><li class="tab"><button type="button" data-href="#item.java-4">VegBurger/ChickenBurger.java</button></li><li class="tab"><button type="button" data-href="#item.java-5">Meal.java</button></li><li class="tab"><button type="button" data-href="#item.java-6">MealBuilder.java</button></li><li class="tab"><button type="button" data-href="#item.java-7">BuilderPatternDemo.java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="item.java-1"><pre class="line-numbers language-none"><code class="language-none">//创建一个表示食物条目和食物包装的接口。
public interface Item {
   public String name();
   public Packing packing();
   public float price();    
}

public interface Packing {
   public String pack();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="item.java-2"><pre class="line-numbers language-none"><code class="language-none">//创建实现 Packing 接口的实体类。
public class Wrapper implements Packing {
 
   @Override
   public String pack() {
      return "Wrapper";
   }
}

public class Bottle implements Packing {
 
   @Override
   public String pack() {
      return "Bottle";
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="item.java-3"><pre class="line-numbers language-none"><code class="language-none">//创建实现 Item 接口的抽象类，该类提供了默认的功能。
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new Wrapper();
   }
 
   @Override
   public abstract float price();
}


public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="item.java-4"><pre class="line-numbers language-none"><code class="language-none">//创建扩展了 Burger 和 ColdDrink 的实体类
public class VegBurger extends Burger {
 
   @Override
   public float price() {
      return 25.0f;
   }
 
   @Override
   public String name() {
      return "Veg Burger";
   }
}

public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return "Chicken Burger";
   }
}

public class Coke extends ColdDrink {
 
   @Override
   public float price() {
      return 30.0f;
   }
 
   @Override
   public String name() {
      return "Coke";
   }
}

public class Pepsi extends ColdDrink {
 
   @Override
   public float price() {
      return 35.0f;
   }
 
   @Override
   public String name() {
      return "Pepsi";
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="item.java-5"><pre class="line-numbers language-none"><code class="language-none">//创建一个 Meal 类，带有上面定义的 Item 对象
import java.util.ArrayList;
import java.util.List;
 
public class Meal {
   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print("Item : "+item.name());
         System.out.print(", Packing : "+item.packing().pack());
         System.out.println(", Price : "+item.price());
      }        
   }    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="item.java-6"><pre class="line-numbers language-none"><code class="language-none">//创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象
public class MealBuilder {
 
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   
 
   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="item.java-7"><pre class="line-numbers language-none"><code class="language-none">//BuiderPatternDemo 使用 MealBuilder 来演示建造者模式（Builder Pattern）
public class BuilderPatternDemo {
   public static void main(String[] args) {
      MealBuilder mealBuilder = new MealBuilder();
 
      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println("Veg Meal");
      vegMeal.showItems();
      System.out.println("Total Cost: " +vegMeal.getCost());
 
      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println("\n\nNon-Veg Meal");
      nonVegMeal.showItems();
      System.out.println("Total Cost: " +nonVegMeal.getCost());
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h4 id="5-原型模式（Prototype-Pattern）"><a href="#5-原型模式（Prototype-Pattern）" class="headerlink" title="5.原型模式（Prototype Pattern）"></a>5.原型模式（Prototype Pattern）</h4><h5 id="1-意图-2"><a href="#1-意图-2" class="headerlink" title="1.意图"></a>1.意图</h5><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>主要解决：在运行期建立和删除原型。</p>
<h5 id="2-原型模式实现"><a href="#2-原型模式实现" class="headerlink" title="2.原型模式实现"></a>2.原型模式实现</h5><p>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。</p>
<p>PrototypePatternDemo 类使用 ShapeCache 类来获取 Shape 对象<br><a href="../JavaEE/javaBase-7.jpg">原型模式实现</a></p>
<div class="tabs" id="shape.java"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#shape.java-1">Shape.java</button></li><li class="tab"><button type="button" data-href="#shape.java-2">Rectangle.java</button></li><li class="tab"><button type="button" data-href="#shape.java-3">ShapeCache.java</button></li><li class="tab"><button type="button" data-href="#shape.java-4">PrototypePatternDemo.java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="shape.java-1"><pre class="line-numbers language-none"><code class="language-none">//创建一个实现了 Cloneable 接口的抽象类。
public abstract class Shape implements Cloneable {
   
   private String id;
   protected String type;
   
   abstract void draw();
   
   public String getType(){
      return type;
   }
   
   public String getId() {
      return id;
   }
   
   public void setId(String id) {
      this.id = id;
   }
   
   public Object clone() {
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-2"><pre class="line-numbers language-none"><code class="language-none">//创建扩展了上面抽象类的实体类
public class Rectangle extends Shape {
 
   public Rectangle(){
     type = "Rectangle";
   }
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}

public class Square extends Shape {
 
   public Square(){
     type = "Square";
   }
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}

public class Circle extends Shape {
 
   public Circle(){
     type = "Circle";
   }
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-3"><pre class="line-numbers language-none"><code class="language-none">//创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。
import java.util.Hashtable;
 
public class ShapeCache {
    
   private static Hashtable&lt;String, Shape&gt; shapeMap 
      = new Hashtable&lt;String, Shape&gt;();
 
   public static Shape getShape(String shapeId) {
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone();
   }
 
   // 对每种形状都运行数据库查询，并创建该形状
   // shapeMap.put(shapeKey, shape);
   // 例如，我们要添加三种形状
   public static void loadCache() {
      Circle circle = new Circle();
      circle.setId("1");
      shapeMap.put(circle.getId(),circle);
 
      Square square = new Square();
      square.setId("2");
      shapeMap.put(square.getId(),square);
 
      Rectangle rectangle = new Rectangle();
      rectangle.setId("3");
      shapeMap.put(rectangle.getId(),rectangle);
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="shape.java-4"><pre class="line-numbers language-none"><code class="language-none">//PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。
public class PrototypePatternDemo {
   public static void main(String[] args) {
      ShapeCache.loadCache();
 
      Shape clonedShape = (Shape) ShapeCache.getShape("1");
      System.out.println("Shape : " + clonedShape.getType());        
 
      Shape clonedShape2 = (Shape) ShapeCache.getShape("2");
      System.out.println("Shape : " + clonedShape2.getType());        
 
      Shape clonedShape3 = (Shape) ShapeCache.getShape("3");
      System.out.println("Shape : " + clonedShape3.getType());        
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>


<h3 id="2-结构型模式"><a href="#2-结构型模式" class="headerlink" title="2.结构型模式"></a>2.结构型模式</h3><p>这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。</p>
<h4 id="1-适配器模式（Adapter-Pattern）"><a href="#1-适配器模式（Adapter-Pattern）" class="headerlink" title="1.适配器模式（Adapter Pattern）"></a>1.适配器模式（Adapter Pattern）</h4><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.runoob.com/design-pattern/adapter-pattern.html"></a></p>
<p><a href="../JavaEE/javaBase-8.jpg"></a></p>
<h4 id="2-桥接模式（Bridge-Pattern）"><a href="#2-桥接模式（Bridge-Pattern）" class="headerlink" title="2.桥接模式（Bridge Pattern）"></a>2.桥接模式（Bridge Pattern）</h4><h4 id="3-过滤器模式（Filter、Criteria-Pattern）"><a href="#3-过滤器模式（Filter、Criteria-Pattern）" class="headerlink" title="3.过滤器模式（Filter、Criteria Pattern）"></a>3.过滤器模式（Filter、Criteria Pattern）</h4><h4 id="4-组合模式（Composite-Pattern）"><a href="#4-组合模式（Composite-Pattern）" class="headerlink" title="4.组合模式（Composite Pattern）"></a>4.组合模式（Composite Pattern）</h4><h4 id="5-装饰器模式（Decorator-Pattern）"><a href="#5-装饰器模式（Decorator-Pattern）" class="headerlink" title="5.装饰器模式（Decorator Pattern）"></a>5.装饰器模式（Decorator Pattern）</h4><h4 id="6-外观模式（Facade-Pattern）"><a href="#6-外观模式（Facade-Pattern）" class="headerlink" title="6.外观模式（Facade Pattern）"></a>6.外观模式（Facade Pattern）</h4><h4 id="7-享元模式（Flyweight-Pattern）"><a href="#7-享元模式（Flyweight-Pattern）" class="headerlink" title="7.享元模式（Flyweight Pattern）"></a>7.享元模式（Flyweight Pattern）</h4><h4 id="8-代理模式（Proxy-Pattern）"><a href="#8-代理模式（Proxy-Pattern）" class="headerlink" title="8.代理模式（Proxy Pattern）"></a>8.代理模式（Proxy Pattern）</h4><h3 id="3-行为型模式"><a href="#3-行为型模式" class="headerlink" title="3.行为型模式"></a>3.行为型模式</h3><p>这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。</p>
<h4 id="1-责任链模式（Chain-of-Responsibility-Pattern）"><a href="#1-责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="1.责任链模式（Chain of Responsibility Pattern）"></a>1.责任链模式（Chain of Responsibility Pattern）</h4><h4 id="2-命令模式（Command-Pattern）"><a href="#2-命令模式（Command-Pattern）" class="headerlink" title="2.命令模式（Command Pattern）"></a>2.命令模式（Command Pattern）</h4><h4 id="3-解释器模式（Interpreter-Pattern）"><a href="#3-解释器模式（Interpreter-Pattern）" class="headerlink" title="3.解释器模式（Interpreter Pattern）"></a>3.解释器模式（Interpreter Pattern）</h4><h4 id="4-迭代器模式（Iterator-Pattern）"><a href="#4-迭代器模式（Iterator-Pattern）" class="headerlink" title="4.迭代器模式（Iterator Pattern）"></a>4.迭代器模式（Iterator Pattern）</h4><h4 id="5-中介者模式（Mediator-Pattern）"><a href="#5-中介者模式（Mediator-Pattern）" class="headerlink" title="5.中介者模式（Mediator Pattern）"></a>5.中介者模式（Mediator Pattern）</h4><h4 id="6-备忘录模式（Memento-Pattern）"><a href="#6-备忘录模式（Memento-Pattern）" class="headerlink" title="6.备忘录模式（Memento Pattern）"></a>6.备忘录模式（Memento Pattern）</h4><h4 id="7-观察者模式（Observer-Pattern）"><a href="#7-观察者模式（Observer-Pattern）" class="headerlink" title="7.观察者模式（Observer Pattern）"></a>7.观察者模式（Observer Pattern）</h4><h4 id="8-状态模式（State-Pattern）"><a href="#8-状态模式（State-Pattern）" class="headerlink" title="8.状态模式（State Pattern）"></a>8.状态模式（State Pattern）</h4><h4 id="9-空对象模式（Null-Object-Pattern）"><a href="#9-空对象模式（Null-Object-Pattern）" class="headerlink" title="9.空对象模式（Null Object Pattern）"></a>9.空对象模式（Null Object Pattern）</h4><h4 id="10-策略模式（Strategy-Pattern）"><a href="#10-策略模式（Strategy-Pattern）" class="headerlink" title="10.策略模式（Strategy Pattern）"></a>10.策略模式（Strategy Pattern）</h4><h4 id="11-模板模式（Template-Pattern）"><a href="#11-模板模式（Template-Pattern）" class="headerlink" title="11.模板模式（Template Pattern）"></a>11.模板模式（Template Pattern）</h4><h4 id="12-访问者模式（Visitor-Pattern）"><a href="#12-访问者模式（Visitor-Pattern）" class="headerlink" title="12.访问者模式（Visitor Pattern）"></a>12.访问者模式（Visitor Pattern）</h4><h3 id="4-J2EE模式"><a href="#4-J2EE模式" class="headerlink" title="4.J2EE模式"></a>4.J2EE模式</h3><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p>
<h4 id="1-MVC-模式（MVC-Pattern）"><a href="#1-MVC-模式（MVC-Pattern）" class="headerlink" title="1.MVC 模式（MVC Pattern）"></a>1.MVC 模式（MVC Pattern）</h4><h4 id="2-业务代表模式（Business-Delegate-Pattern）"><a href="#2-业务代表模式（Business-Delegate-Pattern）" class="headerlink" title="2.业务代表模式（Business Delegate Pattern）"></a>2.业务代表模式（Business Delegate Pattern）</h4><h4 id="3-组合实体模式（Composite-Entity-Pattern）"><a href="#3-组合实体模式（Composite-Entity-Pattern）" class="headerlink" title="3.组合实体模式（Composite Entity Pattern）"></a>3.组合实体模式（Composite Entity Pattern）</h4><h4 id="4-数据访问对象模式（Data-Access-Object-Pattern）"><a href="#4-数据访问对象模式（Data-Access-Object-Pattern）" class="headerlink" title="4.数据访问对象模式（Data Access Object Pattern）"></a>4.数据访问对象模式（Data Access Object Pattern）</h4><h4 id="5-前端控制器模式（Front-Controller-Pattern）"><a href="#5-前端控制器模式（Front-Controller-Pattern）" class="headerlink" title="5.前端控制器模式（Front Controller Pattern）"></a>5.前端控制器模式（Front Controller Pattern）</h4><h4 id="6-拦截过滤器模式（Intercepting-Filter-Pattern）"><a href="#6-拦截过滤器模式（Intercepting-Filter-Pattern）" class="headerlink" title="6.拦截过滤器模式（Intercepting Filter Pattern）"></a>6.拦截过滤器模式（Intercepting Filter Pattern）</h4><h4 id="7-服务定位器模式（Service-Locator-Pattern）"><a href="#7-服务定位器模式（Service-Locator-Pattern）" class="headerlink" title="7.服务定位器模式（Service Locator Pattern）"></a>7.服务定位器模式（Service Locator Pattern）</h4><h4 id="8-传输对象模式（Transfer-Object-Pattern）"><a href="#8-传输对象模式（Transfer-Object-Pattern）" class="headerlink" title="8.传输对象模式（Transfer Object Pattern）"></a>8.传输对象模式（Transfer Object Pattern）</h4><div class="tabs" id="istack.java"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#istack.java-1">IStack.java</button></li><li class="tab"><button type="button" data-href="#istack.java-2">Stack.java</button></li><li class="tab"><button type="button" data-href="#istack.java-3">Test.java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="istack.java-1"><pre class="line-numbers language-none"><code class="language-none">public interface IStack&lt;T&gt; {
 
 /**
  * 初始化栈
  * @param maxSize: 数组的最大长度。栈的最大长度。
  */
 public void initStack(int maxSize);
 
 /**
  * 销毁栈
  */
 public void destroyStack();
 
 /**
  * 添加数据，进栈。
  * @param data 要被添加的数据.类型不确定，所以用泛型。
  */
 public void push(T data);
 
 /**
  * 删除栈顶元素
  */
 public void pop();

 /**
  * 判断栈是否为空
  * @return true or false.
  */
 public boolean isEmpty();
 
 /**
  * 获取栈顶元素
  * @return 栈顶数据元素。数据元素的类型不确定，所以是泛型。
  */
 public T getTop();	
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="istack.java-2"><pre class="line-numbers language-none"><code class="language-none">public class Stack&lt;T&gt; implements IStack&lt;T&gt; {

 private int length;// 元素个数。栈的长度。
 private T arr[];// 用于存放数据的数组。因为是顺序栈，所以用数组。数组取值是用角标 arr[0] arr[1] ...
 private int maxSize;

 /**
  * 构造函数
  * 
  * @param maxSize
  *            数组的最大长度
  */
 public Stack(int maxSize) {
  this.maxSize = maxSize;
  initStack(maxSize);
 }

 @Override
 public void initStack(int maxSize) {
  this.maxSize = maxSize;
  // 初始化数组。
  //为什么要初始化数组，因为数组不初始化，就没有分配内存空间，
  //是一个空对象，也就是空指针。
  arr = (T[]) new Object[maxSize];
 }

 @Override
 public void destroyStack() {
  // TODO Auto-generated method stub
 }

 // 添加值 1判断 原有数值长度 是否 已满于最大数组长
 // 2 数值 赋予 原有数组末，数组长增加
 @Override
 public void push(T data) {
  if(this.length &gt;= this.maxSize){
   System.out.println("已满");
   return;
  }
  arr[this.length] = data;
  this.length++;
 }

 // 添加值 1判断 原有数值长度 是否 为零
 // 2 数值 赋予 原有数组 次末，数组长减少
 @Override
 public void pop() {
  if(this.length == 0){
   System.out.println("已经到底，无法pop");
   return;
  }
  arr[this.length-1] = null;
  this.length--;
 }

 // 指针 1判断长度 如果为零返回 否则 返回数组 次长度
 @Override
 public T getTop() {
  if(this.length == 0){
   return null;
   }
  return this.arr[this.length-1];
  
   }

 @Override
 public boolean isEmpty() {
  return this.length == 0;
 }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="istack.java-3"><pre class="line-numbers language-none"><code class="language-none">public class Test {
 
 public static void main(String[] args) {
  Stack&lt;Integer&gt; s = new Stack&lt;&gt;(1024); // 指定栈的长度最大值是1024.

  s.push(1);
  s.push(2);
  s.push(3);
  
  s.pop();
  s.pop();
  
  Integer top = s.getTop();
  System.out.println(top);
 }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>


</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://github.com/Wabi-Sabifag/Wabi-Sabifag.github.io">Wabi-Sabifag</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://Wabi-Sabifag.github.io">https://Wabi-Sabifag.github.io</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Wabi-Sabifag所有。如有转载，请注明来自原作者(但万物开源)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a></div><div class="post_share"><div class="social-share" data-image="/img/23.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="/./img/Wabi-Sabifag.jpg" target="_blank"><img class="post-qr-code-img" src="/./img/Wabi-Sabifag.jpg" alt="BiliBili"/></a><div class="post-qr-code-desc">BiliBili</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/01/02/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"><img class="prev-cover" src="/img/47.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux基础命令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/19/Maven/" title="Maven基础"><img class="cover" src="/img/27.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">Maven基础</div></div></a></div><div><a href="/2023/02/18/JavaEE/" title="JavaEE"><img class="cover" src="/img/22.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-18</div><div class="title">JavaEE</div></div></a></div><div><a href="/2023/08/22/MybatisPlus/" title="MybatisPlus"><img class="cover" src="/img/23.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-22</div><div class="title">MybatisPlus</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://safebooru.org//samples/3404/sample_2d70be5f0453c31b5e9ad641db7cf3fb90ba2c23.jpg?3541071" onerror="this.onerror=null;this.src='https://safebooru.org//samples/3404/sample_2d70be5f0453c31b5e9ad641db7cf3fb90ba2c23.jpg?3541071'" alt="avatar"/></div><div class="author-info__name">Wabi-Sabifag</div><div class="author-info__description">当残风不再，当石烂海竭，我迟迟归场</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://space.bilibili.com/364309102"><i class="fab fa-github"></i><span>我的兴趣都在这里</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wabi-Sabifag" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_61109834" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="fab fa-contao"></i></a><a class="social-icon" href="https://space.bilibili.com/364309102" rel="external nofollow noreferrer" target="_blank" title="BiliBli"><i class="fa fa-bold"></i></a><a class="social-icon" href="mailto:1109388794@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">世界上的事我不可一饮而尽，唯愿至死依然热爱而真切的活着、目睹经途的千万。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80"><span class="toc-text">1.Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-text">1.关键词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-return"><span class="toc-text">1.return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.进制转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E5%8F%82%E4%B8%8E%E5%BD%A2%E5%8F%82"><span class="toc-text">3.实参与形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">4.值传递与引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99"><span class="toc-text">5.构造方法能重载，不能重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">6.抽象类、抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%80%BB%E7%BB%93%E8%A1%A8%E8%BF%B0"><span class="toc-text">1. 总结表述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">2. 核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">3. 抽象类的使用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4. 抽象类注意事项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-abstract%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-text">5.abstract关键字：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%92%8C-%E9%9D%99%E6%80%81-static"><span class="toc-text">7.构造函数 和 静态(static)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81"><span class="toc-text">2.静态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-static-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.static 的特点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. 实例变量和类变量的区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3.静态使用的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.Cookie和Session的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%85%B1%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9A"><span class="toc-text">1.共同之处：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">2.工作原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-Cookie%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.Cookie的工作原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-Session%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.Session的工作原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB"><span class="toc-text">3.区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-session%EF%BC%9A"><span class="toc-text">1.session：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-cookie%EF%BC%9A"><span class="toc-text">2.cookie：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-text">4.区别对比：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84"><span class="toc-text">2.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-List"><span class="toc-text">1.List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-List%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%87%E5%AE%9A%E4%BF%AE%E6%94%B9"><span class="toc-text">1.List数据的指定修改</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MySQL%E5%9F%BA%E7%A1%80"><span class="toc-text">2.MySQL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.数据库类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.五大类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">1.整数类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">2.浮点数类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">3.字符串类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">4.日期类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">5.其他数据类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E7%9B%B8%E4%BC%BC%E6%95%B0%E6%8D%AE%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6.相似数据间的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-int-1-%E4%B8%8Eint-10-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.int(1)与int(10)的区别？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-tinyint-1-%E4%B8%8Etinyint-3-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.tinyint(1)与tinyint(3)的区别？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-char%E4%B8%8Evarchar%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.char与varchar的区别？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-BLOB%E4%B8%8ETEXT%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.BLOB与TEXT的区别？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis%E5%9F%BA%E7%A1%80"><span class="toc-text">3. Redis基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-token-%E8%BF%87%E6%9C%9F%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F%EF%BC%9F"><span class="toc-text">1.token 过期后，如何自动续期？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-token%E8%BF%87%E6%9C%9F%E7%9A%84%E7%BB%AD%E6%9C%9F%E6%96%B9%E6%A1%88"><span class="toc-text">1.token过期的续期方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8D%95token%E6%96%B9%E6%A1%88"><span class="toc-text">1.单token方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%8Ctoken%E6%96%B9%E6%A1%88"><span class="toc-text">2.双token方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E6%96%B9%E6%A1%88"><span class="toc-text">3.微信网页授权方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Redis%E7%BC%93%E5%AD%98token"><span class="toc-text">4.Redis缓存token</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1"><span class="toc-text">1.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-token%E5%A4%B1%E6%95%88%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="toc-text">2.token失效处理方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%BB%E5%8A%A8%E5%A4%84%E7%90%86"><span class="toc-text">1.主动处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%80%9D%E8%B7%AF"><span class="toc-text">1.思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81"><span class="toc-text">2.代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A2%AB%E5%8A%A8%E5%A4%84%E7%90%86"><span class="toc-text">2.被动处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%80%9D%E8%B7%AF-1"><span class="toc-text">1.思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81-1"><span class="toc-text">2.代码</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.Java策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">设计模式的六大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Close-Principle%EF%BC%89"><span class="toc-text">1.开闭原则（Open Close Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle%EF%BC%89"><span class="toc-text">2.里氏代换原则（Liskov Substitution Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%88Dependence-Inversion-Principle%EF%BC%89"><span class="toc-text">3.依赖倒转原则（Dependence Inversion Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle%EF%BC%89"><span class="toc-text">4.接口隔离原则（Interface Segregation Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%8C%E5%8F%88%E7%A7%B0%E6%9C%80%E5%B0%91%E7%9F%A5%E9%81%93%E5%8E%9F%E5%88%99%EF%BC%88Demeter-Principle%EF%BC%89"><span class="toc-text">5.迪米特法则，又称最少知道原则（Demeter Principle）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88Composite-Reuse-Principle%EF%BC%89"><span class="toc-text">6.合成复用原则（Composite Reuse Principle）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89"><span class="toc-text">1.工厂模式（Factory Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%84%8F%E5%9B%BE"><span class="toc-text">1.意图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2%EF%BC%9A"><span class="toc-text">2.工厂模式包含以下几个核心角色：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.工厂模式实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.创建接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-text">2.创建实现接口的实体类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%8E%82%EF%BC%8C%E7%94%9F%E6%88%90%E5%9F%BA%E4%BA%8E%E7%BB%99%E5%AE%9A%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.创建一个工厂，生成基于给定信息的实体类的对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%B7%A5%E5%8E%82%EF%BC%8C%E9%80%9A%E8%BF%87%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.使用该工厂，通过传递类型信息来获取实体类的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory-Pattern%EF%BC%89"><span class="toc-text">2.抽象工厂模式（Abstract Factory Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%84%8F%E5%9B%BE-1"><span class="toc-text">1.意图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.抽象工厂模式实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Pattern%EF%BC%89"><span class="toc-text">3.单例模式（Singleton Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%84%8F%E5%9B%BE%EF%BC%9A"><span class="toc-text">1.意图：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.单例模式实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Pattern%EF%BC%89"><span class="toc-text">4.建造者模式（Builder Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%84%8F%E5%9B%BE%EF%BC%9A-1"><span class="toc-text">1.意图：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.建造者模式实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype-Pattern%EF%BC%89"><span class="toc-text">5.原型模式（Prototype Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%84%8F%E5%9B%BE-2"><span class="toc-text">1.意图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.原型模式实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89"><span class="toc-text">1.适配器模式（Adapter Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge-Pattern%EF%BC%89"><span class="toc-text">2.桥接模式（Bridge Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Filter%E3%80%81Criteria-Pattern%EF%BC%89"><span class="toc-text">3.过滤器模式（Filter、Criteria Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite-Pattern%EF%BC%89"><span class="toc-text">4.组合模式（Composite Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator-Pattern%EF%BC%89"><span class="toc-text">5.装饰器模式（Decorator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade-Pattern%EF%BC%89"><span class="toc-text">6.外观模式（Facade Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight-Pattern%EF%BC%89"><span class="toc-text">7.享元模式（Flyweight Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Pattern%EF%BC%89"><span class="toc-text">8.代理模式（Proxy Pattern）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-of-Responsibility-Pattern%EF%BC%89"><span class="toc-text">1.责任链模式（Chain of Responsibility Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command-Pattern%EF%BC%89"><span class="toc-text">2.命令模式（Command Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Interpreter-Pattern%EF%BC%89"><span class="toc-text">3.解释器模式（Interpreter Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator-Pattern%EF%BC%89"><span class="toc-text">4.迭代器模式（Iterator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Mediator-Pattern%EF%BC%89"><span class="toc-text">5.中介者模式（Mediator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%88Memento-Pattern%EF%BC%89"><span class="toc-text">6.备忘录模式（Memento Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89"><span class="toc-text">7.观察者模式（Observer Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%88State-Pattern%EF%BC%89"><span class="toc-text">8.状态模式（State Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Null-Object-Pattern%EF%BC%89"><span class="toc-text">9.空对象模式（Null Object Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89"><span class="toc-text">10.策略模式（Strategy Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Pattern%EF%BC%89"><span class="toc-text">11.模板模式（Template Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Visitor-Pattern%EF%BC%89"><span class="toc-text">12.访问者模式（Visitor Pattern）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-J2EE%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.J2EE模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MVC-%E6%A8%A1%E5%BC%8F%EF%BC%88MVC-Pattern%EF%BC%89"><span class="toc-text">1.MVC 模式（MVC Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%9A%E5%8A%A1%E4%BB%A3%E8%A1%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Business-Delegate-Pattern%EF%BC%89"><span class="toc-text">2.业务代表模式（Business Delegate Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%88Composite-Entity-Pattern%EF%BC%89"><span class="toc-text">3.组合实体模式（Composite Entity Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Data-Access-Object-Pattern%EF%BC%89"><span class="toc-text">4.数据访问对象模式（Data Access Object Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Front-Controller-Pattern%EF%BC%89"><span class="toc-text">5.前端控制器模式（Front Controller Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Intercepting-Filter-Pattern%EF%BC%89"><span class="toc-text">6.拦截过滤器模式（Intercepting Filter Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Service-Locator-Pattern%EF%BC%89"><span class="toc-text">7.服务定位器模式（Service Locator Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Transfer-Object-Pattern%EF%BC%89"><span class="toc-text">8.传输对象模式（Transfer Object Pattern）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/10/ErrorReport/" title="ErrorReport"><img src="/img/18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ErrorReport"/></a><div class="content"><a class="title" href="/2023/10/10/ErrorReport/" title="ErrorReport">ErrorReport</a><time datetime="2023-10-10T11:00:22.000Z" title="发表于 2023-10-10 19:00:22">2023-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/23/RequirementSpecification/" title="RequirementSpecification"><img src="/img/13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RequirementSpecification"/></a><div class="content"><a class="title" href="/2023/08/23/RequirementSpecification/" title="RequirementSpecification">RequirementSpecification</a><time datetime="2023-08-23T04:55:04.000Z" title="发表于 2023-08-23 12:55:04">2023-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/22/MybatisPlus/" title="MybatisPlus"><img src="/img/23.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MybatisPlus"/></a><div class="content"><a class="title" href="/2023/08/22/MybatisPlus/" title="MybatisPlus">MybatisPlus</a><time datetime="2023-08-22T13:35:35.000Z" title="发表于 2023-08-22 21:35:35">2023-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/Maven/" title="Maven基础"><img src="/img/27.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven基础"/></a><div class="content"><a class="title" href="/2023/08/19/Maven/" title="Maven基础">Maven基础</a><time datetime="2023-08-19T13:49:08.000Z" title="发表于 2023-08-19 21:49:08">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/01/SoftWareTest/" title="SoftWareTest"><img src="/img/15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SoftWareTest"/></a><div class="content"><a class="title" href="/2023/03/01/SoftWareTest/" title="SoftWareTest">SoftWareTest</a><time datetime="2023-03-01T01:40:17.000Z" title="发表于 2023-03-01 09:40:17">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Wabi-Sabifag</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div><a onclick="window.open('https://bilibili.com')"><img src=''>湖公网安备 </a></div> <div>当内心一片虚无的时刻，我将心脏埋入这无尽的土壤</div>  <div>理想主义 现实主义 实用主义</div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" date-type="playlist" data-fixed="true" data-autoplay="true"></div><link rel="stylesheet" href="css/style.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>